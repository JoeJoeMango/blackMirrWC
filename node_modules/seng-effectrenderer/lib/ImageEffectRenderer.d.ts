export default class ImageEffectRenderer {
    static MAX_IMAGE_EFFECT_RENDERERS: number;
    private canvas;
    private gl;
    private width;
    private height;
    private textures;
    private program;
    private posAttributeIndex;
    private uvAttributeIndex;
    private shader;
    private uniformGlobalTime;
    private uniformTime;
    private uniformResolution;
    private quadVBO;
    private requestAnimationID;
    private time;
    private static IERActive;
    private static IERPool;
    private container;
    private animationLoop;
    private canvasScale;
    /**
     * Requires a HTMLCanvasElement and a shader program as a plain text string
     *
     * @param container
     * @param shader
     * @param _animationLoop
     */
    constructor(container: HTMLElement, animationLoop?: boolean, createTemporaryUsed?: boolean);
    /**
     * Create a GL canvas object and stores it in a Pool because we can't have unlimited gl contexts.
     *
     * @param container: HTMLElement and the wrapper of the canvas. Canvas will size based on this element
     * @param shader: Plain text shader that is applied
     * @param animationLoop: Boolean to automatically play the animationFrame to update the canvas
     * @param canvasScale: Number to scale up/down the real canvas size. Can be used to shrink the canvas and render
     * less pixels, which should result in faster rendering.
     */
    static createTemporary(container: HTMLElement, shader: string, animationLoop?: boolean, canvasScale?: number): ImageEffectRenderer;
    /**
     * Add Image to the GL, This can be an HTMLImageElement or a rendered Canvas.
     * Can have up to 4 slots
     *
     * @param image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement
     * @param slotIndex: number from 0 to 3
     * @param clampToEdge
     */
    addImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, slotIndex: number, clampHorizontal?: boolean, clampVertical?: boolean, flipY?: boolean): void;
    updateImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, slotIndex: number, clampHorizontal?: boolean, clampVertical?: boolean, flipY?: boolean): void;
    /**
     * Returns the Canvas Element
     */
    getCanvas(): HTMLCanvasElement;
    /**
     * Play the animationFrame loop
     */
    play(): void;
    /**
     * Stop the animationFrame loop
     */
    stop(): void;
    /**
     * Set a Uniform Floating variable used in the Shader
     * @param name: string
     * @param value: float
     */
    setUniformFloat(name: string, value: number): void;
    /**
     * Set a Uniform Integer variable used in the Shader
     * @param name: string
     * @param value: Int
     */
    setUniformInt(name: string, value: number): void;
    /**
     * Set a Uniform Vec2 variable used in the Shader
     * @param name: string
     * @param value: Vec2
     */
    setUniformVec2(name: string, x: number, y: number): void;
    /**
     * Set a Uniform Vec3 variable used in the Shader
     * @param name: string
     * @param value: Vec3
     */
    setUniformVec3(name: string, x: number, y: number, z: number): void;
    /**
     * Set a Uniform Vec4 variable used in the Shader
     * @param name: string
     * @param value: Vec4
     */
    setUniformVec4(name: string, x: number, y: number, z: number, w: number): void;
    /**
     * Returns the RenderTime for the shader
     */
    readonly renderTime: number;
    /**
     * Draw the new Canvas Frame, can be used to manually update the canvas when a Uniform has changed
     *
     * @param time
     */
    draw(time?: number): void;
    updateSize(): void;
    private compileShader(fsSource);
    private generateNDCQuad();
    /**
     * Release a temporary Canvas context from the pool. Freeing it up for other uses.
     *
     * @param ier
     */
    static releaseTemporary(ier: ImageEffectRenderer): void;
}

"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var ImageEffectRenderer =
/*#__PURE__*/
function () {
  // webgl
  // image input
  // <slotIndex> = texture ID
  // shader
  // uniform
  // quad
  // control
  // (global) context resource management

  /**
   * Requires a HTMLCanvasElement and a shader program as a plain text string
   *
   * @param container
   * @param shader
   * @param _animationLoop
   */
  function ImageEffectRenderer(container, animationLoop, createTemporaryUsed) {
    if (animationLoop === void 0) {
      animationLoop = false;
    }

    if (createTemporaryUsed === void 0) {
      createTemporaryUsed = false;
    }

    Object.defineProperty(this, "canvas", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "gl", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "width", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "height", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "textures", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "program", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "posAttributeIndex", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "uvAttributeIndex", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shader", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "uniformGlobalTime", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "uniformTime", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "uniformResolution", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "quadVBO", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "requestAnimationID", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "time", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "container", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "animationLoop", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "canvasScale", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: 1
    });

    if (!createTemporaryUsed) {
      throw new Error('Use ImageEffectRenderer.createTemporary to create a ImageEffectRenderer');
    }

    this.container = container;
    this.animationLoop = animationLoop;
    this.canvas = document.createElement('canvas');
    this.gl = this.canvas.getContext('experimental-webgl', {
      premultipliedAlpha: true
    });

    if (!this.gl) {
      throw new Error('ImageEffectRenderer: Failed to request a 3D context, aborting...');
    }
  }
  /**
   * Create a GL canvas object and stores it in a Pool because we can't have unlimited gl contexts.
   *
   * @param container: HTMLElement and the wrapper of the canvas. Canvas will size based on this element
   * @param shader: Plain text shader that is applied
   * @param animationLoop: Boolean to automatically play the animationFrame to update the canvas
   * @param canvasScale: Number to scale up/down the real canvas size. Can be used to shrink the canvas and render
   * less pixels, which should result in faster rendering.
   */


  ImageEffectRenderer.createTemporary = function createTemporary(container, shader, animationLoop, canvasScale) {
    if (animationLoop === void 0) {
      animationLoop = false;
    }

    if (canvasScale === void 0) {
      canvasScale = 1;
    }

    var ier = null; // before creating a context, determine if we already reached the maximum number of contexts

    if (ImageEffectRenderer.IERActive.length >= ImageEffectRenderer.MAX_IMAGE_EFFECT_RENDERERS) {
      throw new Error("Maximum number of ImageEffectRenderer's reached, no new ImageEffectRenderer created");
    } // determine if there's an ImageEffectRenderer in the IERPool and if so, re-use its context


    if (ImageEffectRenderer.IERPool.length > 0) {
      // first look for same shader
      var sameShaderFound = false;

      for (var i = 0; i < ImageEffectRenderer.IERPool.length; i++) {
        if (ImageEffectRenderer.IERPool[i].shader === shader) {
          ier = ImageEffectRenderer.IERPool[i];
          ImageEffectRenderer.IERPool.splice(i, 1);
          sameShaderFound = true;
        }
      }

      if (!sameShaderFound) {
        ier = ImageEffectRenderer.IERPool[0];
        ImageEffectRenderer.IERPool.splice(0, 1);
      }
    } else {
      ier = new ImageEffectRenderer(container, animationLoop, true);
    }

    ier.animationLoop = animationLoop;
    ier.container = container;
    ier.canvasScale = canvasScale;
    container.appendChild(ier.canvas);
    ier.updateSize();

    if (!ier.quadVBO) {
      ier.generateNDCQuad();
    }

    if (ier.shader !== shader) {
      if (ier.program) {
        ier.gl.deleteProgram(ier.program);
        ier.program = null;
      }

      ier.compileShader(shader);
      ier.shader = shader;
    } // gl configuration


    ier.gl.clearColor(0, 0, 0, 0);
    ier.gl.viewport(0, 0, ier.canvas.width, ier.canvas.height);
    ier.gl.clear(ier.gl.COLOR_BUFFER_BIT);
    ier.gl.enable(ier.gl.BLEND);
    ier.gl.blendFunc(ier.gl.ONE, ier.gl.ONE_MINUS_SRC_ALPHA);
    ier.width = ier.canvas.width;
    ier.height = ier.canvas.height; // store current ImageEffectRenderer in the list of active IERs

    ImageEffectRenderer.IERActive.push(ier);
    return ier;
  };
  /**
   * Add Image to the GL, This can be an HTMLImageElement or a rendered Canvas.
   * Can have up to 4 slots
   *
   * @param image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement
   * @param slotIndex: number from 0 to 3
   * @param clampToEdge
   */


  var _proto = ImageEffectRenderer.prototype;

  _proto.addImage = function addImage(image, slotIndex, clampHorizontal, clampVertical, flipY) {
    if (clampHorizontal === void 0) {
      clampHorizontal = true;
    }

    if (clampVertical === void 0) {
      clampVertical = true;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    if (slotIndex >= 4) {// console.log('ImageEffectRenderer: A maximum of 4 slots is available, slotIndex is out of bounds.');
    }

    if (!this.textures[slotIndex]) {
      this.textures[slotIndex] = this.gl.createTexture();
    }

    this.gl.useProgram(this.program);
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'iChannel' + slotIndex), slotIndex);
    this.updateImage(image, slotIndex, clampHorizontal, clampVertical, flipY);
  };

  _proto.updateImage = function updateImage(image, slotIndex, clampHorizontal, clampVertical, flipY) {
    if (clampHorizontal === void 0) {
      clampHorizontal = true;
    }

    if (clampVertical === void 0) {
      clampVertical = true;
    }

    if (flipY === void 0) {
      flipY = false;
    }

    this.gl.uniform2f(this.gl.getUniformLocation(this.program, 'iChannelResolution' + slotIndex), image.width, image.height);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[slotIndex]);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, flipY ? 1 : 0);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, clampHorizontal ? this.gl.CLAMP_TO_EDGE : this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, clampVertical ? this.gl.CLAMP_TO_EDGE : this.gl.REPEAT);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
  };
  /**
   * Returns the Canvas Element
   */


  _proto.getCanvas = function getCanvas() {
    return this.canvas;
  };
  /**
   * Play the animationFrame loop
   */


  _proto.play = function play() {
    if (!this.requestAnimationID) {
      this.animationLoop = true;
      this.draw(0);
    }
  };
  /**
   * Stop the animationFrame loop
   */


  _proto.stop = function stop() {
    if (this.requestAnimationID) {
      window.cancelAnimationFrame(this.requestAnimationID);
      this.requestAnimationID = null;
      this.animationLoop = false;
    }
  };
  /**
   * Set a Uniform Floating variable used in the Shader
   * @param name: string
   * @param value: float
   */


  _proto.setUniformFloat = function setUniformFloat(name, value) {
    this.gl.useProgram(this.program);
    this.gl.uniform1f(this.gl.getUniformLocation(this.program, name), value);
  };
  /**
   * Set a Uniform Integer variable used in the Shader
   * @param name: string
   * @param value: Int
   */


  _proto.setUniformInt = function setUniformInt(name, value) {
    this.gl.useProgram(this.program);
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, name), value);
  };
  /**
   * Set a Uniform Vec2 variable used in the Shader
   * @param name: string
   * @param value: Vec2
   */


  _proto.setUniformVec2 = function setUniformVec2(name, x, y) {
    this.gl.useProgram(this.program);
    this.gl.uniform2f(this.gl.getUniformLocation(this.program, name), x, y);
  };
  /**
   * Set a Uniform Vec3 variable used in the Shader
   * @param name: string
   * @param value: Vec3
   */


  _proto.setUniformVec3 = function setUniformVec3(name, x, y, z) {
    this.gl.useProgram(this.program);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, name), x, y, z);
  };
  /**
   * Set a Uniform Vec4 variable used in the Shader
   * @param name: string
   * @param value: Vec4
   */


  _proto.setUniformVec4 = function setUniformVec4(name, x, y, z, w) {
    this.gl.useProgram(this.program);
    this.gl.uniform4f(this.gl.getUniformLocation(this.program, name), x, y, z, w);
  };
  /**
   * Returns the RenderTime for the shader
   */


  /**
   * Draw the new Canvas Frame, can be used to manually update the canvas when a Uniform has changed
   *
   * @param time
   */
  _proto.draw = function draw(time) {
    var _this = this;

    if (time === void 0) {
      time = 0;
    }

    this.time = time / 1000; // determine if screen has been resized. If so, adjust viewport

    if (this.canvas.width !== this.width || this.canvas.height !== this.height) {
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      this.width = this.canvas.width;
      this.height = this.canvas.height;
    } // clear


    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    this.gl.useProgram(this.program); // global uniforms

    this.gl.uniform1f(this.uniformGlobalTime, this.time);
    this.gl.uniform1f(this.uniformTime, this.time);
    this.gl.uniform2f(this.uniformResolution, this.canvas.width, this.canvas.height); // texture/channel uniforms

    for (var slotIndex = 0; slotIndex < this.textures.length; ++slotIndex) {
      this.gl.activeTexture(this.gl.TEXTURE0 + slotIndex);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[slotIndex]);
    } // render NDC quad


    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadVBO);
    this.gl.enableVertexAttribArray(this.posAttributeIndex); // 4 32-bit values = 4 4-byte values

    this.gl.vertexAttribPointer(this.posAttributeIndex, 2, this.gl.FLOAT, false, 4 * 4, 0);
    this.gl.enableVertexAttribArray(this.uvAttributeIndex);
    this.gl.vertexAttribPointer(this.uvAttributeIndex, 2, this.gl.FLOAT, false, 4 * 4, 2 * 4);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);

    if (this.animationLoop) {
      this.requestAnimationID = window.requestAnimationFrame(function (time) {
        return _this.draw(time);
      });
    }
  };

  _proto.updateSize = function updateSize() {
    this.canvas.width = this.container.offsetWidth * this.canvasScale;
    this.canvas.height = this.container.offsetHeight * this.canvasScale;
    this.canvas.style.width = this.container.offsetWidth + "px";
    this.canvas.style.height = this.container.offsetHeight + "px";
  };

  _proto.compileShader = function compileShader(fsSource) {
    this.program = this.gl.createProgram();
    var vs = this.gl.createShader(this.gl.VERTEX_SHADER);
    var fs = this.gl.createShader(this.gl.FRAGMENT_SHADER); // vertex shader

    var vsSource = "\n            attribute vec2 aPos;\n            attribute vec2 aUV;\n            \n            varying vec2 vUV0;\n            \n            void main(void) {\n                vUV0 = aUV;\n                gl_Position = vec4(aPos, 0.0, 1.0);\n            }\n        ";
    this.gl.shaderSource(vs, vsSource);
    this.gl.compileShader(vs);
    var success = this.gl.getShaderParameter(vs, this.gl.COMPILE_STATUS);

    if (!success) {
      throw new Error("ImageEffectRenderer: Vertex shader compilation failed: " + this.gl.getShaderInfoLog(vs));
    } // fragment shader


    var fsMainSource = "\n            #ifdef GL_ES\n                precision highp float;\n            #endif\n            \n            varying vec2 vUV0;\n            \n            uniform vec2 iResolution;\n            uniform float iTime;\n            uniform float iGlobalTime;\n            uniform vec4 iMouse;\n            \n            uniform highp sampler2D iChannel0;\n            uniform highp sampler2D iChannel1;\n            uniform highp sampler2D iChannel2;\n            uniform highp sampler2D iChannel3;\n            \n            uniform vec2 iChannelResolution0;\n            uniform vec2 iChannelResolution1;\n            uniform vec2 iChannelResolution2;\n            uniform vec2 iChannelResolution3;\n            \n            void mainImage(out vec4, vec2);\n            \n            vec4 texture(sampler2D tex, vec2 uv) {\n                return texture2D(tex, uv);\n            }\n            \n            void main(void) {\n            \tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                mainImage(gl_FragColor, gl_FragCoord.xy);\n            }\n        ";
    this.gl.shaderSource(fs, fsMainSource + fsSource);
    this.gl.compileShader(fs);
    success = this.gl.getShaderParameter(fs, this.gl.COMPILE_STATUS);

    if (!success) {
      throw new Error("ImageEffectRenderer: Shader compilation failed: " + this.gl.getShaderInfoLog(fs));
    } // link shaders


    this.gl.attachShader(this.program, vs);
    this.gl.attachShader(this.program, fs);
    this.gl.linkProgram(this.program);
    success = this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS);

    if (!success) {
      throw new Error("ImageEffectRenderer: Program linking failed: " + this.gl.getProgramInfoLog(this.program));
    } // get attribute locations


    this.posAttributeIndex = this.gl.getAttribLocation(this.program, 'aPos');
    this.uvAttributeIndex = this.gl.getAttribLocation(this.program, 'aUV'); // get uniform locations

    this.gl.useProgram(this.program);
    this.uniformGlobalTime = this.gl.getUniformLocation(this.program, 'iGlobalTime');
    this.uniformTime = this.gl.getUniformLocation(this.program, 'iTime');
    this.uniformResolution = this.gl.getUniformLocation(this.program, 'iResolution');
  };

  _proto.generateNDCQuad = function generateNDCQuad() {
    // prettier-ignore
    var vertices = new Float32Array([-1, 1, 0, 1, -1, -1, 0, 0, 1, 1, 1, 1, 1, -1, 1, 0]);
    this.quadVBO = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadVBO);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
  };
  /**
   * Release a temporary Canvas context from the pool. Freeing it up for other uses.
   *
   * @param ier
   */


  ImageEffectRenderer.releaseTemporary = function releaseTemporary(ier) {
    ier.stop();
    ier.canvas.parentNode.removeChild(ier.canvas); // remove from active IER instances

    var index = ImageEffectRenderer.IERActive.indexOf(ier);

    if (index > -1) {
      ImageEffectRenderer.IERActive.splice(index, 1);
    } else {
      throw new Error("Can't find the EffectRenderer in the active pool");
    } // add current instance to pool


    ImageEffectRenderer.IERPool.push(ier);
  };

  (0, _createClass2.default)(ImageEffectRenderer, [{
    key: "renderTime",
    get: function get() {
      return this.time;
    }
  }]);
  return ImageEffectRenderer;
}();

exports.default = ImageEffectRenderer;
Object.defineProperty(ImageEffectRenderer, "MAX_IMAGE_EFFECT_RENDERERS", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 10
});
Object.defineProperty(ImageEffectRenderer, "IERActive", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: []
});
Object.defineProperty(ImageEffectRenderer, "IERPool", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: []
});